package com.proyectofinal.backend.Services;

import com.proyectofinal.backend.Models.CalendarificModels.Holiday;
import com.proyectofinal.backend.Models.CalendarificModels.HolidayResponse;
import com.proyectofinal.backend.Models.ShiftException;
import com.proyectofinal.backend.Repositories.ShiftExceptionRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;

@Service
public class CalendarificService {

    private final ShiftExceptionRepository shiftExceptionRepository;
    private final RestTemplate restTemplate;
    
    @Value("${calendarific.api.key}")
    private String apiKey;
    
    private static final String BASE_URL = "https://calendarific.com/api/v2/holidays";
    private static final SimpleDateFormat ISO_FORMAT = new SimpleDateFormat("yyyy-MM-dd");

    public CalendarificService(ShiftExceptionRepository shiftExceptionRepository) {
        this.shiftExceptionRepository = shiftExceptionRepository;
        this.restTemplate = new RestTemplate();
        ISO_FORMAT.setTimeZone(TimeZone.getTimeZone("UTC"));
    }

    /**
     * Importa los festivos nacionales de España para un año específico.
     * Primero elimina los festivos existentes del mismo año para evitar duplicados.
     * @param year El año para el que se importarán los festivos
     * @return Número de festivos importados
     */
    public int importNationalHolidays(int year) {
        // Primero eliminamos los festivos nacionales existentes para este año
        deleteExistingNationalHolidays(year);
        
        String url = BASE_URL + "?api_key=" + apiKey + "&country=ES&year=" + year;
        
        try {
            HolidayResponse response = restTemplate.getForObject(url, HolidayResponse.class);
            
            if (response == null || response.getResponse() == null || response.getResponse().getHolidays() == null) {
                return 0;
            }
            
            List<Holiday> holidays = response.getResponse().getHolidays();
            int count = 0;
            
            for (Holiday holiday : holidays) {
                // Solo importar festivos nacionales
                if (holiday.getType() != null && holiday.getType().contains("National holiday")) {
                    ShiftException exception = convertHolidayToException(holiday);
                    shiftExceptionRepository.save(exception);
                    count++;
                }
            }
            
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
    
    /**
     * Elimina los festivos nacionales existentes para un año específico
     * @param year El año para el que se eliminarán los festivos
     * @return Número de festivos eliminados
     */
    public int deleteExistingNationalHolidays(int year) {
        Calendar cal = Calendar.getInstance();
        cal.set(year, Calendar.JANUARY, 1, 0, 0, 0);
        Date yearStart = cal.getTime();
        
        cal.set(year + 1, Calendar.JANUARY, 1, 0, 0, 0);
        Date yearEnd = cal.getTime();
        
        List<ShiftException> holidays = shiftExceptionRepository.findByTypeAndEmployeeIdIsNullAndDateRange(
                "NATIONAL_HOLIDAY", yearStart, yearEnd);
        
        int count = holidays.size();
        shiftExceptionRepository.deleteAll(holidays);
        
        return count;
    }
    
    /**
     * Verifica si ya existen festivos importados para un año específico
     * @param year El año para verificar
     * @return true si ya existen festivos para ese año
     */
    public boolean holidaysExistForYear(int year) {
        Calendar cal = Calendar.getInstance();
        cal.set(year, Calendar.JANUARY, 1, 0, 0, 0);
        Date yearStart = cal.getTime();
        
        cal.set(year + 1, Calendar.JANUARY, 1, 0, 0, 0);
        Date yearEnd = cal.getTime();
        
        List<ShiftException> holidays = shiftExceptionRepository.findByTypeAndYear("NATIONAL_HOLIDAY", yearStart, yearEnd);
        return !holidays.isEmpty();
    }
    
    /**
     * Convierte un objeto Holiday de Calendarific a un ShiftException
     */
    private ShiftException convertHolidayToException(Holiday holiday) throws ParseException {
        ShiftException exception = new ShiftException();
        exception.setEmployeeId(null); // Aplica a todos los empleados
        exception.setType("NATIONAL_HOLIDAY");
        exception.setDescription(holiday.getName());
        exception.setAutoGenerated(true);
        
        // Parsear la fecha ISO
        String isoDate = holiday.getDate().getIso();
        Date holidayDate = ISO_FORMAT.parse(isoDate);
        
        exception.setStartDate(holidayDate);
        exception.setEndDate(holidayDate); // Mismo día inicio y fin para festivos de un día
        
        return exception;
    }
} 